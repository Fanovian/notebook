---
comments: true
---

# Garbage Collection：垃圾收集

## 引入

一般划分程序的内存空间方法是：

- code 段
- static 段：编译时刻已经知道所占空间的值
  - 全局变量
  - 编译器生成的数据
- stack 段：活动记录中的数据结构，典型的是局部变量、函数参数等
- heap 段：由程序来控制的、动态分配与销毁的内存空间
  - 对 C 来说是诸如 `malloc`、`free` 等函数
  - 对 Java 来说是诸如 `new` 等关键字

如何对内存空间进行管理？可以分为**手动（Manual）**和**自动（Automatic）**两种方式。

手动方式，例如 C/C++ 中的 `malloc` 和 `free`，需要程序员手动分配和释放内存。这种方式容易导致内存泄漏（Memory Leak）、双次释放（Double Free）、释放后使用（Use After Free）等问题。同时，针对存储的 bug 其实是比较难找的，一个 storage bug 可能会在距离源程序很远（时间或空间）的地方才会被发现。

自动方式会在程序运行时自动管理内存，常见的方式是垃圾回收（Garbage Collection, GC）。

### 垃圾的定义

垃圾（Garbage）是指**分配，但不再使用**的内存空间。垃圾回收的目标是自动释放这些不再使用的内存空间。一片空间是不是垃圾无法精确确定，只能有一个估计：用可达性来估计。

- 以 heap 来分配的空间，如果不被任何程序中的指针链所能够访问到，则认为这片空间是垃圾
- 保守的估计：不可达就是垃圾（实际上，垃圾有可能是可达的）
    - x 可达，当且仅当
        - 一个寄存器包含 x 的指针，或者
        - 其他可达的 y 包含 x 的指针

垃圾回收不是由编译器来做的，是运行时系统来做的。

## Mark-and-Sweap 垃圾回收